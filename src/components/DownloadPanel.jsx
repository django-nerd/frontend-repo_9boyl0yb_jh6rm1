import { useState } from 'react'
import { Download } from 'lucide-react'

export default function DownloadPanel() {
  const [copied, setCopied] = useState(false)
  const code = `// BallController.cs\nusing UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class BallController : MonoBehaviour\n{\n    [Header("Tuning")]\n    public float bounceForce = 12f;\n    public float fallSpeedLimit = -25f;\n    public float bounceCooldown = 0.05f;\n\n    [Header("FX")]\n    public ParticleSystem bounceParticles;\n    public AudioSource bounceAudio;\n    public TrailRenderer trail;\n\n    private Rigidbody rb;\n    private float lastBounceTime = -999f;\n    private bool isDead = false;\n\n    void Awake() {\n        rb = GetComponent<Rigidbody>();\n        rb.interpolation = RigidbodyInterpolation.Interpolate;\n        rb.collisionDetectionMode = CollisionDetectionMode.Discrete;\n        // For gap clipping prevention you can switch to ContinuousDynamic if needed.\n        rb.useGravity = true;\n    }\n\n    void FixedUpdate() {\n        // Clamp downward speed\n        if (rb.velocity.y < fallSpeedLimit) {\n            rb.velocity = new Vector3(rb.velocity.x, fallSpeedLimit, rb.velocity.z);\n        }\n    }\n\n    void OnCollisionEnter(Collision collision) {\n        if (isDead) return;\n\n        if (collision.collider.CompareTag("Dead") || collision.collider.CompareTag("DeadZone")) {\n            Die();\n            return;\n        }\n\n        if (Time.time - lastBounceTime < bounceCooldown) return;\n\n        // Only bounce when hitting from above\n        foreach (var contact in collision.contacts) {\n            if (Vector3.Dot(contact.normal, Vector3.up) > 0.5f) {\n                Vector3 v = rb.velocity;\n                v.y = bounceForce;\n                rb.velocity = v;\n                lastBounceTime = Time.time;\n                if (bounceParticles) bounceParticles.Play();\n                if (bounceAudio) bounceAudio.Play();\n                // simple squash & stretch using scale tween\n                StopAllCoroutines();\n                StartCoroutine(ScaleKick());\n                break;\n            }\n        }\n    }\n\n    System.Collections.IEnumerator ScaleKick() {\n        Vector3 baseScale = Vector3.one;\n        Vector3 squashed = new Vector3(1.1f, 0.85f, 1.1f);\n        float t = 0f;\n        while (t < 1f) {\n            t += Time.deltaTime * 12f;\n            float k = Mathf.Sin(t * Mathf.PI);\n            transform.localScale = Vector3.Lerp(baseScale, squashed, k);\n            yield return null;\n        }\n        transform.localScale = baseScale;\n    }\n\n    public void Die() {\n        if (isDead) return;\n        isDead = true;\n        rb.isKinematic = true;\n        GameManager.Instance.GameOver();\n    }\n}\n\n// TowerRotator.cs\nusing UnityEngine;\n\npublic class TowerRotator : MonoBehaviour\n{\n    public Transform towerRoot;\n    public float rotationSensitivity = 0.4f;\n\n    float lastX;\n    bool dragging;\n\n    void Update() {\n        // Mouse (editor/PC)\n        if (Input.GetMouseButtonDown(0)) { dragging = true; lastX = Input.mousePosition.x; }\n        if (Input.GetMouseButtonUp(0)) dragging = false;\n        if (dragging) {\n            float dx = Input.mousePosition.x - lastX;\n            lastX = Input.mousePosition.x;\n            Rotate(dx);\n        }\n\n        // Touch\n        if (Input.touchCount > 0) {\n            var t = Input.GetTouch(0);\n            if (t.phase == TouchPhase.Began) { dragging = true; lastX = t.position.x; }\n            if (t.phase == TouchPhase.Moved && dragging) { Rotate(t.deltaPosition.x); }\n            if (t.phase == TouchPhase.Ended || t.phase == TouchPhase.Canceled) dragging = false;\n        }\n    }\n\n    void Rotate(float deltaX) {\n        if (!towerRoot) return;\n        float angle = -deltaX * rotationSensitivity;\n        towerRoot.Rotate(0f, angle, 0f, Space.World);\n    }\n}\n\n// CameraFollow.cs\nusing UnityEngine;\n\npublic class CameraFollow : MonoBehaviour\n{\n    public Transform target;\n    public Vector3 cameraOffset = new Vector3(0, 6, -8);\n    public float followSpeed = 6f;\n    public float minYClampOffset = 2f;\n\n    void LateUpdate() {\n        if (!target) return;\n        Vector3 desired = target.position + cameraOffset;\n        // Clamp camera so it never goes below target minus some offset\n        desired.y = Mathf.Max(desired.y, target.position.y - minYClampOffset);\n        transform.position = Vector3.Lerp(transform.position, desired, followSpeed * Time.deltaTime);\n        transform.LookAt(target.position);\n    }\n}\n\n// GameManager.cs\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n\npublic class GameManager : MonoBehaviour\n{\n    public static GameManager Instance;\n\n    void Awake(){ if(Instance==null){ Instance=this; DontDestroyOnLoad(gameObject);} else Destroy(gameObject); }\n\n    public void GameOver(){\n        // restart current scene\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    }\n\n    public void NextLevel(){\n        int i = SceneManager.GetActiveScene().buildIndex;\n        int next = (i + 1) % SceneManager.sceneCountInBuildSettings;\n        SceneManager.LoadScene(next);\n    }\n}\n`;

  const copy = async () => {
    await navigator.clipboard.writeText(code)
    setCopied(true)
    setTimeout(() => setCopied(false), 1500)
  }

  return (
    <div className="rounded-xl border border-gray-200 bg-white/70 backdrop-blur p-6 shadow-sm">
      <div className="flex items-center justify-between gap-4">
        <div>
          <h3 className="font-semibold text-gray-900">Unity C# Scripts</h3>
          <p className="text-sm text-gray-600">Copy the full, ready-to-use scripts for Ball, Tower, Camera, and Game flow.</p>
        </div>
        <button onClick={copy} className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-indigo-600 text-white shadow hover:bg-indigo-700">
          <Download className="h-4 w-4" /> {copied ? 'Copied!' : 'Copy all'}
        </button>
      </div>
      <div className="mt-4 text-xs text-gray-500">
        Tip: Tag your hazard meshes as "Dead" and add a bottom trigger tagged "DeadZone". Platforms should use non-trigger colliders.
      </div>
    </div>
  )
}
